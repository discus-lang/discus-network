module Network.Socket

export {
  networkSocket_socket;
  networkSocket_bind;
  networkSocket_connect;
  networkSocket_write;
  networkSocket_read;
}

import foreign abstract type
  SOCKET : Effect

import foreign c value

  socket : CInt -> CInt -> CInt -> S SOCKET Word64
  bind : FD -> Word64# -> Nat# -> S SOCKET Word64
  connect : FD -> Word64# -> Nat# -> S SOCKET Word64

  write : [r : Region]. FD -> Word64# -> Nat# -> S (SOCKET + Read r) Word64
  read : [r : Region]. FD -> Word64# -> Nat# -> S (SOCKET + Write r) Word64

  ddcVectorGuts : {@r: Region} -> Vector# r Word8# -> Word64#

  get_errno : Unit -> S SOCKET Nat

import Data.Numeric.Word8
import Data.Numeric.Word16
import Data.Numeric.Word32
import Data.Numeric.Word64
import Data.Numeric.Int
import Data.Numeric.Nat
import Data.Either

where

type CInt = Int
type FD = Nat

type Vector = Vector#

type PortNumber = Word16

type HostAddress = Word32

data Socket where
  Socket : FD -> Socket

data Family where
  AF_INET : Family

data SocketType where
  SOCK_STREAM : SocketType

type ProtocolNumber = Nat

-- | Errors, represented by their errno value.
data SocketError where
  SocketError : Nat -> SocketError

networkSocket_socket
  (family: Family)
  (type_: SocketType)
  (protocol: ProtocolNumber)
  : S SOCKET (Either SocketError Socket)
  = do
        ret = socket (familyToC family) (socketTypeToC type_) (promote# protocol)
        if band ret 0x80000000w64 /= 0w64
          then Left (SocketError (get_errno ()))
          else Right (Socket (truncate# ret))

familyToC (x: Family): CInt
  = case x of
      AF_INET -> 2i

socketTypeToC (x: SocketType): CInt
  = case x of
      SOCK_STREAM -> 1i

---------------------------------------------------------------------------------------

data SockAddr where
  SockAddrInet
     : PortNumber
    -> HostAddress
    -> SockAddr

networkSocket_bind : Socket -> SockAddr -> S SOCKET (Either SocketError Unit)
networkSocket_bind (Socket s) sockaddr
  = private r with { Alloc r; Write r; Read r } in
    do    
        sockaddr_vec : Vector r Word8 = vectorAlloc# [r] size_sockaddr
        writeSockAddr sockaddr sockaddr_vec
        ret = bind s (ddcVectorGuts sockaddr_vec) size_sockaddr
        if band ret 0x80000000w64 /= 0w64
          then Left (SocketError (get_errno ()))
          else Right ()

networkSocket_connect : Socket -> SockAddr -> S SOCKET (Either SocketError Unit)
networkSocket_connect (Socket s) sockaddr
  = private r with { Alloc r; Write r; Read r } in
    do    
        sockaddr_vec : Vector r Word8 = vectorAlloc# [r] size_sockaddr
        writeSockAddr sockaddr sockaddr_vec
        ret = connect s (ddcVectorGuts sockaddr_vec) size_sockaddr
        if band ret 0x80000000w64 /= 0w64
          then Left (SocketError (get_errno ()))
          else Right ()

networkSocket_write [r : Region] ((Socket s): Socket) (vec: Vector r Word8): S (SOCKET + Read r) (Either SocketError Nat)
  = do
        ret = write [r] s (ddcVectorGuts vec) (vectorLength# [r] [Word8#] vec)
        if band ret 0x80000000w64 /= 0w64
          then Left (SocketError (get_errno ()))
          else Right (truncate# ret)

networkSocket_read [r : Region] ((Socket s): Socket) (vec: Vector r Word8): S (SOCKET + Write r) (Either SocketError Nat)
  = do
        ret = read [r] s (ddcVectorGuts vec) (vectorLength# [r] [Word8#] vec)
        if band ret 0x80000000w64 /= 0w64
          then Left (SocketError (get_errno ()))
          else Right (truncate# ret)

size_sockaddr: Nat = 16 

-- | Write a SockAddr structure to a memory buffer.
-- The buffer must have size at least `size_sockaddr`.
writeSockAddr [r : Region] (sa: SockAddr) (vec: Vector r Word8): S (Write r) Unit
  = case sa of
      SockAddrInet port addr ->
        do  -- struct sockaddr_in {
            --   uint8_t        sin_family;
            --   uint16_t       sin_port;
            --   struct in_addr sin_addr;
            -- }

            putWord8    vec 0 (truncate# (familyToC AF_INET))
            putWord16be vec 2 port
            putWord32be vec 4 addr
            ()

putWord8 [r: Region] (vec: Vector r Word8) (index: Nat) (val: Word8): S (Write r) Unit
  = do
        vectorWrite# vec index val
        ()

putWord16be [r: Region] (vec: Vector r Word8) (index: Nat) (val: Word16): S (Write r) Unit
  = do 
        vectorWrite# vec (add# index 0) (truncate# (shr# val 8w16))
        vectorWrite# vec (add# index 1) (truncate# (shr# val 0w16))
        ()

putWord32be [r: Region] (vec: Vector r Word8) (index: Nat) (val: Word32): S (Write r) Unit
  = do 
        vectorWrite# vec (add# index 0) (truncate# (shr# val 24w32))
        vectorWrite# vec (add# index 1) (truncate# (shr# val 16w32))
        vectorWrite# vec (add# index 2) (truncate# (shr# val  8w32))
        vectorWrite# vec (add# index 3) (truncate# (shr# val  0w32))
        ()
